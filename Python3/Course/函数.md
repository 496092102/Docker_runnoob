## 函数
定义函数时，需要确定函数名和参数个数

如果有必要，可以先对参数的数据类型做检查；
```
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
```
函数体内部可以用return随时返回函数结果，函数执行完毕也没有return语句时，自动return None。函数可以同时返回多个值，但其实就是一个tuple。

Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。

默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！

*args是可变参数的定义，args接收的是一个tuple；**kw是关键字参数的定义，kw接收的是一个dict。

调用函数时可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过\*args传入：func(*(1, 2, 3))；

调用函数时关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过\**kw传入：func(**{'a': 1, 'b': 2})。

使用/*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。

定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。

使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。

针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。

Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

在Python中，能用1行实现的功能，决不能使用5行代码。代码越少，开发效率越高。

\>>> (0, 1, 2, 3, 4, 5)[:3]    》 (0, 1, 2)

\>>> 'ABCDEFG'[:3]    》'ABC'

\>>> list(range(1, 11))    》[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

\>>> [x * x for x in range(1, 11)]    》[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

\>>> [x * x for x in range(1, 11) if x % 2 == 0]    》[4, 16, 36, 64, 100]

\>>> [m + n for m in 'ABC' for n in 'XYZ']    》['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']

\>>> [d for d in os.listdir('.')]   os.listdir可以列出文件和目录

